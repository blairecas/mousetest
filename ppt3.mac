	.title	PPT3
	.mcall	.print .exit
	.enabl	LC
	.list	MEB
	.asect

.=1000
Start:	; TODO: load .pt3 file

	; start PPU code
	mov	#PPUSta, R4		; run PPU code
	mov	#<PPUEnd-PPUSta>/2, R5
	call	PPURun
	; wait for PPU code be in working order
	tst	PpuComm
	beq	.-4
	; check for AY presence
	tst	PpuNoAy
	beq	10$
	.print	#MsgNoAy
	br	CpuExit

10$:	call	PlayPt3

CpuExit:
	; ask PPU for exit
	mov	#-1, PpuComm
	tst	PpuComm
	bne	.-4
	; exit
	.exit

MsgNoAy:	.asciz	"ERROR: No AY device present on PPU @#177360"
		.even

.=.+32.
.=.&^B1111111111110000
PpuAyRegisters:	.byte	24, 1, 0, 0, 0, 0, 0, 76, 17, 0, 0, 0, 0, 0, 0, 0
.=.+16.
.=.&^B1111111111110000

Old100Int:	.word	0
VSyncCount:	.word	0

VSyncInt:
	inc	VsyncCount
	rti

; play PT3 cycle
PlayPt3:
	; save vsync int addr and set a new one
	mtps	#200
	mov	@#100, Old100Int
	mov	#VSyncInt, @#100
	mtps	#0

	call	Init
10$:
	tst	VSyncCount
	beq	10$
	clr	VSyncCount
	; prepare AY regs
	call	Play
	; end of file?
	tst	END_OF_PT3FILE
	beq	10$

	call	Mute
	return

; //////////////////////////////////////////////////////////////////////////////
; // CPU -> PPU exchange	
; //////////////////////////////////////////////////////////////////////////////

MsgPpuNoMemory:	
	.asciz	"ERROR: Unable to allocate memory in PPU"
	.even

; PPU message
;
PPmsg:	.word	PPArr	; address of beginning of array
        .word	177777	; end of transmission

; PPU data exchange array
;
PPArr:	.byte	0	; return value (0 - OK)
PPCmd:	.byte	0	; command
	.word	32	; device type (32 - PPU mem)
PPApp:	.word	0	; address for PPU
PPAcp:	.word	0	; address for CPU
PPLen:	.word	0	; length in words

; send command to PPU with exch array
PPSen:	mov	R0, -(SP)
	mov	R1, -(SP)
	mov	#PPMsg, R0	; array address
	mov	#5, R1		; bytes to send+1 (sending from @#PP_MSG)
	br	1$
2$:	movb	(R0)+, @#176676
1$:	tstb	@#176674	; test if we are ready to send
	bpl	1$		; cycle if >= 0 (not set last bit in byte)
	sob	R1, 2$
	mov	(SP)+, R1
	mov	(SP)+, R0
	return

; send and start PPU code
; R4 - start addr in CPU
; R5 - length / 2
PPURun:	movb	#1, PPCmd	; 1 - allocate memory
	mov	R5, PPLen
	call	PPSen
	tstb	PPArr		; test if allocate success
	beq	1$		; 0 - OK
	.print	#MsgPpuNoMemory
	.exit			; fatal error - out of memory in PPU
1$:	movb	#20, PPCmd	; 20 - write to PPU mem
	mov	R5, PPLen
	mov 	R4, PPAcp
	call	PPSen
	movb	#30, PPCmd	; 30 - run
	call	PPSen
	return

; release PPU memory
PPRele:	movb	#2, PPCmd	; 2 - release memory
	call	PPSen
	return


; //////////////////////////////////////////////////////////////////////////////	
; // PPU
; //////////////////////////////////////////////////////////////////////////////

; PPU starting addr
PPUSta:
	mtps	#200
	clr	R0
	call	@7132(R0)		; stop FD motor

	; damn that hacks - need to correct memory descriptors
	mov	PC, R0
	add	#PpuSta-., R0		; start of program
	mov	#PpuEnd-PpuSta, -(R0)	; write length of current PPU code block
	sub	#4, R0			; addr of our descriptor
	mov	PC, R1
	add	#PpuEnd-., R1		; end of program
	mov	#77772, R2
	sub	R1, R2			; length of free block (assume our program is last though it's incorrect)
	clr	(R1)+			; 'free'
	mov	R0, (R1)+		; addr of previous descriptor
	mov	R2, (R1)+		; length of free mem

	; check AY presence
	mov	@#4, -(SP)		; save trap int addr (todo: save psw?)
	mov	PC, R0			; new trap int addr
	add	#TrapInt-., R0
	mov	R0, @#4			; set it
	clr	R1			; check for AY
	mtps	#0
	tst	@#177360
	mtps	#200
	mov	(SP)+, @#4		; restore trap int addr
	mov	R1, PpuNoAy		; write AY presence into PPU mem
	mov	#PpuNoAy/2, @#177010	; write AY presence into CPU mem
	mov	R1, @#177014

	; signal to CPU that we are working now
	mov	#PpuComm/2, @#177010
	mov	#1, @#177014

; get into cycle, await data from CPU and write it to AY
PPUMain:
	mov	#PpuComm/2, @#177010
	mov	@#177014, R0
	bmi	PPUExit			; check for command 'PPU code exit'
	cmp	R0, #2			; asking to write AY registers?
	bne	PPUMain			; nope - cycle again

	; write 14. AY registers (if AY is present)
	tst	PpuNoAy
	bne	90$
	mov	#177010, R4
	mov	#177014, R5
	; set port number
	mov	#PpuAyRegisters/2+7, (R4)
	mov	(R5), R0
	beq	90$			; no port - exiting
	mov	R0, R2
	; cycle regs except #13.
	mov	#6., R3
	clr	R1
	mov	#PpuAyRegisters/2, (R4)
10$:	mov	(R5), R0
	mov	R1, (R2)
	movb	R0, (R2)
	inc	R1
	swab	R0
	mov	R1, (R2)
	movb	R0, (R2)
	inc	R1
	inc	(R4)
	sob	R3, 10$
	; 12-th
	mov	(R5), R0
	mov	R1, (R2)
	movb	R0, (R2)
	inc	R1
	swab	R0
	; 13-th reg
;	tstb	R0
;	bmi	90$
;	mov	R1, (R2)
;	movb	R0, (R2)

90$:	; set command parameter to 1 and cycle again
	mov	#PpuComm/2, @#177010
	mov	#1, @#177014
	br	PPUMain

PPUExit:
	; TODO: mute AY if present
	mov	#PpuComm/2, @#177010	; signal to CPU that we are finished
	clr	@#177014
	mtps	#0
	return

TrapInt:
	inc	R1
	rti

PpuNoAy:	.word	0		; =1 -> no AY device
PpuComm:	.word	0		; =1 -> PPU code is working now
					; <0 <- ask PPU code to exit
PPUEnd:

; /////////////////////////////////////////////////////////////////////////////
; // PT3 routines
; /////////////////////////////////////////////////////////////////////////////

; Based on:
; CSI MultiPlayer 3 for CSIDOS by KUVO (БК-0011М)
; https://csi.pdp-11.ru/

	AY_TONA = 0
	AY_TONB = 2
	AY_TONC = 4
	AY_NOISE = 6
	AY_MIXER = 7
	AY_AMPLITUDEA = 8.
	AY_AMPLITUDEB = 9.
	AY_AMPLITUDEC = 10.
	AY_ENVELOPE = 11.
	AY_ENVELOPETYPE = 13.

	CHP_POSITION_IN_ORNAMENT = 0 
	CHP_POSITION_IN_SAMPLE = 1 
	CHP_CURRENT_AMPLITUDE_SLIDING= 2 
	CHP_CURRENT_NOISE_SLIDING = 3 
	CHP_CURRENT_ENVELOPE_SLIDING = 4 
	CHP_CURRENT_TON_SLIDING = 6 
	CHP_TON_ACCUMULATOR = 8. 
	CHP_TON_SLIDE_COUNT = 10.   
	CHP_CURRENT_ONOFF = 11.   
	CHP_ONOFF_DELAY = 12.   
	CHP_OFFON_DELAY = 13.   
	CHP_ENVELOPE_ENABLED = 14.   
	CHP_SIMPLEGLISS = 15.   
	CHP_ENABLED = 16.   
	CHP_ADDRESS_IN_PATTERN = 18.   
	CHP_ORNAMENTPOINTER = 20.   
	CHP_SAMPLEPOINTER = 22.   
	CHP_SLIDE_TO_NOTE = 24.   
	CHP_NOTE = 26.   
	CHP_TON_SLIDE_STEP = 28.   
	CHP_TON_DELTA = 30.   
	CHP_NUMBER_OF_NOTES_TO_SKIP = 32.   
	CHP_TON_SLIDE_DELAY = 33.   
	CHP_NOTE_SKIP_COUNTER = 34.   
	CHP_VOLUME = 35.   
	CHP_TONE_REG = 36.   
	CHP_AMPL_REG = 37.   
	CHP = 38.

	PARAM_VERSION = 		0
	PARAM_DELAY =	 		1
	PARAM_ENV_DELAY =	 	2

	PARAM_MODULE_ADDRESS =	 	4
	PARAM_SAMPLESPOINTERS = 	6
	PARAM_ORNAMENTSPOINTERS =	10
	PARAM_PATTERNSPOINTER = 	12
	PARAM_LOOPPOSITION = 		14
	PARAM_CURRENTPOSITION = 	16

	PARAM_VAR0START =	 	20

	PARAM_PRNOTE =			PARAM_VAR0START
	PARAM_PRSLIDING =	 	22
	PARAM_ADDTOENVELOPE =	 	24
	PARAM_ENV_SLIDE_ADD =		26
	PARAM_CUR_ENV_SLIDE =		30
	PARAM_ADDTONOISE =		32
	PARAM_DELAYCOUNTER =		34
	PARAM_CUR_ENV_DELAY =		35
	PARAM_NOISE_BASE =		36

	PARAM_CHANNEL_A =	 	40
	PARAM_CHANNEL_B =	 	PARAM_CHANNEL_A + CHP
	PARAM_CHANNEL_C = 		PARAM_CHANNEL_B + CHP

	PARAM_AYREGS =			PARAM_CHANNEL_C + CHP

	PARAM_VOL_TAB = 		PARAM_AYREGS
	PARAM_NOTE_TAB =		PARAM_VOL_TAB + 256.

	PARAM_SIZE =			96.*2 + PARAM_NOTE_TAB

	PARAM_ENVELOPE_BASE =	 	PARAM_AYREGS + 14.
			
	PARAM_TAB_WORK = PARAM_VOL_TAB + 16. 
	PARAM_TAB_WORK_OLD_1 = PARAM_TAB_WORK
	PARAM_TAB_WORK_OLD_2 = PARAM_TAB_WORK_OLD_1 + 24.
	PARAM_TAB_WORK_OLD_3 = PARAM_TAB_WORK_OLD_2 + 24.
	PARAM_TAB_WORK_OLD_0 = PARAM_TAB_WORK_OLD_3 + 2.
	PARAM_TAB_WORK_NEW_0 = PARAM_TAB_WORK_OLD_0
	PARAM_TAB_WORK_NEW_1 = PARAM_TAB_WORK_OLD_1
	PARAM_TAB_WORK_NEW_2 = PARAM_TAB_WORK_NEW_0 + 24.
	PARAM_TAB_WORK_NEW_3 = PARAM_TAB_WORK_OLD_3

	PARAM_VAR0END =			PARAM_TAB_WORK


PLAYER_ENTRY_POINTS:
	.word	Init 					;+0  First call before playback
	.word	Play 					;+2  Main play call for the next position in PT3 file (one quark, one tick)
	.word	Mute 					;+4  Mute the sound

INTEGRATION_POINTS:
	FRAME_NUMBER:		.WORD 0 				;+6  Incremented by one each time the PLAY entry point is accessed
	TS_PRESENT:		.WORD 0 				;+10 TS sign
	SEL_DEVICE:		.WORD 0 				;+12 Auto selected device: 0 - legacy AY/YM or TurboSound or GryphonSound, 1 - AZBK 
	PARAMETERS_AY1_ADDR:	.WORD PARAMETERS_AY1 			;+14 Address of the operating parameters of AY1
	PARAMETERS_AY2_ADDR:	.WORD PARAMETERS_AY2 			;+16 Address of the operating parameters of AY2
	AYREGS_AY1:		.WORD PARAMETERS_AY1 + PARAM_AYREGS	;+20 Address of last sent AY1 register values
	AYREGS_AY2:		.WORD PARAMETERS_AY2 + PARAM_AYREGS	;+22 Address of last sent AY2 register values
	PT3FILE_MODULE1_ADDR:	.WORD PT3FILE 				;+24 PT3 file address
	PT3FILE_MODULE2_ADDR:	.WORD 0 				;+26 Address of module 2 (TS) in PT3 file
	PT3FILE_END_ADDR:	.WORD 0 				;+30 Address of end PT3 file
	END_OF_PT3FILE:		.WORD 0 				;+32 CODA. End of PT3 file reached (incremented by one each time)
	NO_REPEAT_MODE:		.WORD 0 				;+34 Play without repeat. Set (not zero) before INIT call.
	REPETITION_NUMBER: 	.WORD 0 				;+36 Number of elapsed repetitions after end of PT3 file
	CUR_PARAMS_ADDR:	.WORD 0


TS_ID:	.ascii	"PT3!PT3!02TS"
TS_ID_END:
TS_ID_CHECK:
	mov	#4, R4
10$:	cmpb	-(R0), -(R2)
	bne	11$
	sob	R4, 10$
11$:	return

; Initialization of pt3 module 
Init:
	clr	TS_PRESENT
	clr	SEL_DEVICE
	clr	FRAME_NUMBER
	clr	END_OF_PT3FILE
	clr	PT3FILE_MODULE2_ADDR
	clr	REPETITION_NUMBER
	mov	#PT3FILE_END, PT3FILE_END_ADDR

	mov	#PARAM_DEVICES_AY1, R3
	clr	(R3)+				; legacy (not needed)
	clr	(R3)+				; gsound (not needed)
	mov	#177360, (R3)+			; AY_1_PORT_AZBK in UKNC is fixed 177360
	mov	PT3FILE_MODULE1_ADDR, R1

TS_DETECT:
	mov	PT3FILE_END_ADDR, R0
	mov	#TS_ID_END, R2
	call	TS_ID_CHECK
	bne	INIT_NEXT
	sub	#2, R0				; SKIP LENGTH OF SECOND MODULE
	call	TS_ID_CHECK
	bne	INIT_NEXT
	clr	R5				; GET OFFSET TO SECOND MODULE
	bisb	-(R0), R5
	swab	R5
	bisb	-(R0), R5
	add	PT3FILE_MODULE1_ADDR, R5 	; GET ADDRESS OF SECOND MODULE
	call	TS_ID_CHECK
	bne	INIT_NEXT
	inc	TS_PRESENT

	mov	R5, -(SP)
	call	INIT_NEXT
	mov	(SP)+, R1

	mov	R1, PT3FILE_MODULE2_ADDR
	mov	#PARAM_DEVICES_AY2, R3
	clr	(R3)+				; legacy (not needed)
	clr	(R3)+				; gsound (not needed)
	mov	#177364, (R3)+			; AY_2_PORT_AZBK in UKNC is fixed 177362

INIT_NEXT:
	mov	R3, CUR_PARAMS_ADDR
	mov	R1, PARAM_MODULE_ADDRESS(R3)
	mov	R1, R5  
	movb	100.(R5), PARAM_DELAY(R3)
	add	#200., R1   
	mov	R1, PARAM_CURRENTPOSITION(R3)
	movb	102.(R5), R2 
	add	R2, R1
	inc	R1
	mov	R1, PARAM_LOOPPOSITION(R3)
	clr	R1
	bisb	104.(R5), R1 
	swab	R1
	bisb	103.(R5), R1 
	add	R5, R1  
	mov	R1, PARAM_PATTERNSPOINTER(R3) 
	mov	#169., R1
	add	R5, R1  
	mov	R1, PARAM_ORNAMENTSPOINTERS(R3)  
	mov	#105., R1
	add	R5, R1  
	mov	R1, PARAM_SAMPLESPOINTERS(R3)

 	mov	R5, -(SP)
 
 	mov	#TABLES_PACK, R4 
	mov	#PARAM_TAB_WORK + 98., R5
	add	R3, R5

	mov	#4, R3
	mov	#12., R2
10$: 	mov	(R4)+, R0   
	asl	R0  
	br	12$  
11$: 	clr	R1
	bisb	(R4)+, R1   
	add	R1, R0  
	add	R1, R0
12$: 	mov	R0, -(R5)   
	sob	R2, 11$
	movb	(R4)+, R2   
	inc	R4
	bic	#1, R4  
	sob	R3, 10$

	mov	CUR_PARAMS_ADDR, R5

 	mov	#PARAM_VAR0START, R1
 	add	R5, R1
	mov	#PARAM_VAR0END-PARAM_VAR0START, R3
13$: 	clrb	(R1)+
	sob	R3, 13$

	movb	#1, PARAM_DELAYCOUNTER(R5)
	mov	#^xF001, R0 
	mov	#EMPTY_SAM_ORN, R2
	mov	#PARAM_CHANNEL_A, R4
	add	R5, R4

	mov	(PC)+, R3
	.byte	AY_TONA, AY_AMPLITUDEA
	call	FILL
			
	mov	(PC)+, R3
	.byte	AY_TONB, AY_AMPLITUDEB
	call	FILL
			
	mov	(PC)+, R3
	.byte	AY_TONC, AY_AMPLITUDEC
	call	FILL

	mov	(SP)+, R5

	movb	13.(R5), R0  
	sub	#60, R0  
	bcs	14$  
	cmpb	R0, #10.
	blo	15$
14$:	mov	#6, R0   
15$: 	mov	CUR_PARAMS_ADDR, R2
	movb	R0, PARAM_VERSION(R2) 
	mov	R0, -(SP)   
	cmpb	R0, #4   
	movb	99.(R5), R0
	rolb	R0
	bicb	#177770, R0

NOTE_TABLE_MAKER:
	mov	R1, -(SP)   
	mov	#NT_DATA, R1
	add	R0, R1
	add	R0, R1
	add	R0, R1  
	clr	R2
	bisb	(R1)+, R2   
	mov	(PC)+, R0
	nop	
	tstb	(R1)+   
	beq	10$
	mov	(PC)+, R0   
 	clc	
10$: 	mov	R0, MULTY_SUBR

	clr	R3
	bisb	(R1), R3
	add	#TABLES, R3
	add	(SP)+, R2   

	mov	R3, -(SP)
	mov	#PARAM_NOTE_TAB, R1 
	add	CUR_PARAMS_ADDR, R1
	mov	R1, -(SP)

	mov	#12., R4 
11$: 	mov	(R2)+, R3   

	mov	R1, -(SP)
	mov	#8., R5  
12$:	clc
	ror	R3
	call	MULTY_SUBR   
	mov	R3, R0
	adc	R0
	mov	R0, (R1)
	add	#24., R1
	sob	R5, 12$
	mov	(SP)+, R1
	tst	(R1)+   
	sob	R4, 11$

	mov	(SP)+, R2   
	mov	(SP)+, R1   

	cmp	R1, #TAB_C_OLD_1
	bne	13$
	mov	CUR_PARAMS_ADDR, R0

	movb	#^xFD, PARAM_NOTE_TAB+56(R0)


13$:	clr	R0
	bisb	(R1)+, R0
	beq	15$
	clr	R5
	rorb	R0  
	rol	R5  
	aslb	R0  
	add	R0, R2  
	tst	R5  
	beq	14$
	sub	#2, (R2)
14$: 	inc	(R2)
	sub	R0, R2 
	br	13$

15$: 	mov	(SP)+, R0   

VOL_TABLE_MAKER:
	mov	#21, R3 
	clr	R1  
	cmpb	R0, #5  
	mov	(PC)+, R0
	aslb	R0  
	bhis	10$
	dec	R3  
	mov	R3, R1  
	mov	(PC)+, R0
	nop	 
10$: 	mov	R0, MULTY_SUBR

	mov	#PARAM_VOL_TAB, R4 
	add	CUR_PARAMS_ADDR, R4
	mov	R4, R5
	mov	#16., R2 
	add	R2, R5
	mov	#256./2, R0
11$: 	clr	(R4)+   
	sob	R0, 11$

12$: 	mov	R3, -(SP)  

	add	R3, R1  
	mov	#0, R3  
	sbc	R3  

13$: 	movb	R3, R0  
	mov	R3, R4  
	clrb	R4
	swab	R4  
	call	MULTY_SUBR
	adcb	R4
	movb	R4, (R5)+
	add	R1, R3
	inc	R2  
	mov	R2, R0
	bic	#177760, R0
	bne	13$
	mov	(SP)+, R3
	cmp	R1, #119.
	bne	14$
	inc	R1
14$: 	tstb	R2  
	bne	12$

	jmp	REG_OUT

MULTY_SUBR:
	nop 
	return

Play:		
	inc	FRAME_NUMBER

	mov	#PARAMETERS_AY1, R4
	tst	TS_PRESENT
	beq	PLAY_NEXT

	call	PLAY_NEXT
	mov	#PARAMETERS_AY2, R4

PLAY_NEXT:
	mov	R4, CUR_PARAMS_ADDR
	clr	PARAM_ADDTOENVELOPE(R4)
	clrb	PARAM_AYREGS + AY_MIXER(R4)
	movb	#-1, PARAM_AYREGS + AY_ENVELOPETYPE(R4)
	decb	PARAM_DELAYCOUNTER(R4)
 	bhi	15$
	mov	#PARAM_CHANNEL_A, R5
 	add	R4, R5
 	decb	CHP_NOTE_SKIP_COUNTER(R5)
 	bne	12$
 	mov	CHP_ADDRESS_IN_PATTERN(R5), R3
 	tstb	(R3)
 	bne	11$
	clrb	PARAM_NOISE_BASE(R4)
 	mov	PARAM_CURRENTPOSITION(R4), R0
 	inc	R0
 	movb	(R0), R1

 	cmpb	#377, R1
 	bne	10$

	inc	END_OF_PT3FILE

 	tst	NO_REPEAT_MODE
 	beq	100$

	incb	PARAM_DELAYCOUNTER(R4)
	incb	PARAM_CHANNEL_A + CHP_NOTE_SKIP_COUNTER(R4)
	jmp	Mute

100$:	mov	PARAM_LOOPPOSITION(R4), R0
 	movb	(R0), R1

	inc	REPETITION_NUMBER 				; Next repeat

10$:	mov	R0, PARAM_CURRENTPOSITION(R4)
	bic	#177400, R1
	asl	R1
	add	PARAM_PATTERNSPOINTER(R4), R1 
 	mov	PARAM_MODULE_ADDRESS(R4), R2

	clr	R3
 	bisb	(R1)+, R3   
 	swab	R3
 	bisb	(R1)+, R3   
 	swab	R3   
 	add	R2, R3

 	clr	R0
 	bisb	(R1)+, R0
	swab	R0
	bisb	(R1)+, R0
	swab	R0
	add	R2, R0
	mov	R0, PARAM_CHANNEL_B + CHP_ADDRESS_IN_PATTERN(R4)

	clr	R0
	bisb	(R1)+, R0
	swab	R0
	bisb	(R1)+, R0
	swab	R0
	add	R2, R0
	mov	R0, PARAM_CHANNEL_C + CHP_ADDRESS_IN_PATTERN(R4)

11$:	call	PATTERN_INTERPR
 	mov	R3, CHP_ADDRESS_IN_PATTERN(R5)

12$: 	add	#CHP, R5
	decb	CHP_NOTE_SKIP_COUNTER(R5)
 	bne	13$
	mov	CHP_ADDRESS_IN_PATTERN(R5), R3
 	call	PATTERN_INTERPR
 	mov	R3, CHP_ADDRESS_IN_PATTERN(R5)

13$: 	add	#CHP, R5
	decb	CHP_NOTE_SKIP_COUNTER(R5)
 	bne	14$
 	mov	CHP_ADDRESS_IN_PATTERN(R5), R3
 	call	PATTERN_INTERPR
 	mov	R3, CHP_ADDRESS_IN_PATTERN(R5)

14$: 	movb	PARAM_DELAY(R4), PARAM_DELAYCOUNTER(R4)

15$: 	mov	#PARAM_CHANNEL_A, R5
	add	R4, R5
	call	CHANGE_REGS
	call	CHANGE_REGS
 	call	CHANGE_REGS

 	movb	PARAM_NOISE_BASE(R2), R0  
 	add	PARAM_ADDTONOISE(R2), R0
 	movb	R0, PARAM_AYREGS + AY_NOISE(R2)

	mov	PARAM_ENVELOPE_BASE(R2), R0
	add	PARAM_ADDTOENVELOPE(R2), R0
	add	PARAM_CUR_ENV_SLIDE(R2), R0
	movb	R0, PARAM_AYREGS + AY_ENVELOPE(R2)
	swab	R0
	movb	R0, PARAM_AYREGS + AY_ENVELOPE + 1(R2)

	mov	#PARAM_CUR_ENV_DELAY, R0
	add	R2, R0
	tstb	(R0)
	beq	REG_OUT
	decb	(R0)
	bne	REG_OUT
	movb	PARAM_ENV_DELAY(R2), (R0)
	add	PARAM_ENV_SLIDE_ADD(R2), PARAM_CUR_ENV_SLIDE(R2)

; AY registers ready
REG_OUT:
	mov	CUR_PARAMS_ADDR, R0
	mov	R0, R4
	add	#PARAM_AYREGS, R4
	; copy regs
	mov	#PpuAyRegisters, R5
	mov	-(R0), 14.(R5)				; copy AY port number
	mov	#14., R3
	movb	(R4)+, (R5)+
	sob	R3, .-2
	; write regs to AY on PPU bus
	mov	#2, PpuComm
	cmp	PpuComm, #2
	beq	.-6
	return

MUTE:	; TODO: Mute
MUTE:
	mov	#PARAMETERS_AY1, R4
	call	MUTE_NEXT
	mov	#PARAMETERS_AY2, R4
MUTE_NEXT:
	mov	R4, CUR_PARAMS_ADDR
	clr	PARAM_AYREGS + AY_AMPLITUDEA(R4)
	clrb	PARAM_AYREGS + AY_AMPLITUDEC(R4)
	movb	#77, PARAM_AYREGS + AY_MIXER(R4)
	br	REG_OUT


PD_ORSM:
	clrb	CHP_ENVELOPE_ENABLED(R5)
	call	SET_ORNAMENT
	movb	(R3)+, R0
	br	PD_SAM_

PD_SAM:
	sub	#^xD0, R0
	asl	R0

PD_SAM_:
	add	PARAM_SAMPLESPOINTERS(R4), R0
	clr	R1
	bisb	(R0)+, R1
	swab	R1
	bisb	(R0), R1
	swab	R1
	tst	R1
	beq	10$
	add	PARAM_MODULE_ADDRESS(R4), R1
	mov	R1, CHP_SAMPLEPOINTER(R5)
10$:	br	PD_LOOP

PD_VOL: 	
	bic	#^xFFF0, R0
	asl	R0
	asl	R0
	asl	R0
	asl	R0
	movb	R0, CHP_VOLUME(R5)
	br	PD_LOOP

PD_EOFF: 
	clrb	CHP_ENVELOPE_ENABLED(R5)
	clrb	CHP_POSITION_IN_ORNAMENT(R5)
	br	PD_LOOP

PD_SORE: 	
	bic	#^xFFF0, R0
	decb	R0
	bne	PD_ENV
	movb	(R3)+, CHP_NUMBER_OF_NOTES_TO_SKIP(R5)
	br	PD_LOOP

PD_ENV: 
	call	SET_ENVELOPE
	clrb	CHP_POSITION_IN_ORNAMENT(R5)
	br	PD_LOOP

PD_ORN: 	
	call	SET_ORNAMENT
	br	PD_LOOP

PD_ESAM: 	
	clrb	CHP_ENVELOPE_ENABLED(R5)
	bic	#^xFFF0, R0
	beq	10$
	call	SET_ENVELOPE
10$:	clrb	CHP_POSITION_IN_ORNAMENT(R5)
	movb	(R3)+, R0
	br	PD_SAM_

PATTERN_INTERPR:
	mov	CHP_NOTE(R5), PARAM_PRNOTE(R4)
	mov	CHP_CURRENT_TON_SLIDING(R5), PARAM_PRSLIDING(R4)

PD_LOOP: 	
	clr	R0
	bisb	(R3)+, R0
	cmpb	R0, #^xF0
	bhis	PD_ORSM  
	cmpb	R0, #^xD0
	beq	PD_FIN  
	bhi	PD_SAM  
	cmpb	R0, #^xC0
	beq	PD_REL  
	bhi	PD_VOL
	cmpb	R0, #^xB0
	beq	PD_EOFF  
	bhi	PD_SORE  
  
	cmpb	R0, #^x50
	bhis	PD_NOTE  
	cmpb	R0, #0X40
	bhis	PD_ORN  
	cmpb	R0, #0X20
	bhis	PD_NOIS 
	cmpb	R0, #^x10
	bhis	PD_ESAM 
  
	asl	R0
	mov	SPEC_SUBR(R0), -(SP)  
	br	PD_LOOP

PD_NOIS:
	bic	#^xFFE0, R0
	movb	R0, PARAM_NOISE_BASE(R4)
	br	PD_LOOP

PD_REL:
	clrb	CHP_ENABLED(R5)
	br	PD_RES

PD_NOTE:	
	sub	#^x50, R0
	mov	R0, CHP_NOTE(R5)
	movb	#-1, CHP_ENABLED(R5)

PD_RES: 
	mov	R5, R0
	clr	(R0)+   
	clr	(R0)+   
	clr	(R0)+   
	clr	(R0)+   
	clr	(R0)+   
	clr	(R0) 

PD_FIN: 
	movb	CHP_NUMBER_OF_NOTES_TO_SKIP(R5), CHP_NOTE_SKIP_COUNTER(R5)
	return

SUBR_PORTM:
	clrb	CHP_SIMPLEGLISS(R5)
	movb	(R3)+, R0

 	inc	R3
	inc	R3
	movb	R0, CHP_TON_SLIDE_DELAY(R5)
	movb	R0, CHP_TON_SLIDE_COUNT(R5)
	mov	CHP_NOTE(R5), R2
	mov	R2, CHP_SLIDE_TO_NOTE(R5)
	asl	R2
	add	R4, R2
	mov	PARAM_NOTE_TAB(R2), R2
	mov	PARAM_PRNOTE(R4), R1
	mov	R1, CHP_NOTE(R5)
	asl	R1
	add	R4, R1
	mov	PARAM_NOTE_TAB(R1), R1
	sub	R1, R2
	mov	R2, CHP_TON_DELTA(R5)   
	mov	CHP_CURRENT_TON_SLIDING(R5), R1
	cmpb	PARAM_VERSION(R4), #6
	blo	OLDPRTM  
	mov	PARAM_PRSLIDING(R4), R1
	mov	R1, CHP_CURRENT_TON_SLIDING(R5)

OLDPRTM:
 	clr	R0
	bisb	(R3)+, R0   
	swab	R0
	bisb	(R3)+, R0   
	swab	R0
	tst	R0   
	bpl	10$
	neg	R0
10$:	sub	R1, R2  
	bpl	11$
	neg	R0
11$:	mov	R0, CHP_TON_SLIDE_STEP(R5)
	clrb	CHP_CURRENT_ONOFF(R5)
	return	

SUBR_GLISS:
	movb	(PC), CHP_SIMPLEGLISS(R5)
	movb	(R3)+, R0
	movb	R0, CHP_TON_SLIDE_DELAY(R5)
	bne	GL36
 
	cmpb	PARAM_VERSION(R4), #7 
	blo	GL36
	incb	R0  
GL36: 	movb	R0, CHP_TON_SLIDE_COUNT(R5)
	movb	(R3)+, CHP_TON_SLIDE_STEP(R5) 
	movb	(R3)+, CHP_TON_SLIDE_STEP + 1(R5) 
	clrb	CHP_CURRENT_ONOFF(R5)
	return

SUBR_SMPOS:
	movb	(R3)+, CHP_POSITION_IN_SAMPLE(R5)
	return

SUBR_ORPOS:
	movb	(R3)+, CHP_POSITION_IN_ORNAMENT(R5)
	return

SUBR_VIBRT:
	movb	(R3), CHP_ONOFF_DELAY(R5)
	movb	(R3)+, CHP_CURRENT_ONOFF(R5)
	movb	(R3)+, CHP_OFFON_DELAY(R5)
	clrb	CHP_TON_SLIDE_COUNT(R5)
	clr	CHP_CURRENT_TON_SLIDING(R5)
	return

SUBR_ENGLS:
	movb	(R3), PARAM_ENV_DELAY(R4)
	movb	(R3)+, PARAM_CUR_ENV_DELAY(R4)
	movb	(R3)+, PARAM_ENV_SLIDE_ADD(R4)
	movb	(R3)+, PARAM_ENV_SLIDE_ADD + 1(R4)
	return

SUBR_DELAY:
	movb	(R3)+, PARAM_DELAY(R4)
	return

SET_ENVELOPE:
	movb	#^x10, CHP_ENVELOPE_ENABLED(R5)
	movb	R0, PARAM_AYREGS + AY_ENVELOPETYPE(R4)
	movb	(R3)+, PARAM_ENVELOPE_BASE + 1(R4)
	movb	(R3)+, PARAM_ENVELOPE_BASE(R4) 
	clrb	PARAM_CUR_ENV_DELAY(R4)
	clr	PARAM_CUR_ENV_SLIDE(R4)
SUBR_NOP:
	return

SET_ORNAMENT:
 	bic	#^xFFF0, R0
	asl	R0
	add	PARAM_ORNAMENTSPOINTERS(R4), R0
	clr	R1
	bisb	(R0)+, R1
	swab	R1
	bisb	(R0), R1
	swab	R1
	tst	R1
	bne	10$
	mov	#EMPTY_SAM_ORN, R1
	br	11$
10$:	add	PARAM_MODULE_ADDRESS(R4), R1
11$:	mov	R1, CHP_ORNAMENTPOINTER(R5)
	clrb	CHP_POSITION_IN_ORNAMENT(R5)
	return

SPEC_SUBR: 	
	.WORD   SUBR_NOP
	.WORD   SUBR_GLISS 
	.WORD   SUBR_PORTM 
	.WORD   SUBR_SMPOS 
	.WORD   SUBR_ORPOS 
	.WORD   SUBR_VIBRT 
	.WORD   SUBR_NOP
	.WORD   SUBR_NOP
	.WORD   SUBR_ENGLS
	.WORD   SUBR_DELAY 
	.WORD   SUBR_NOP
	.WORD   SUBR_NOP
	.WORD   SUBR_NOP
	.WORD   SUBR_NOP
	.WORD   SUBR_NOP
	.WORD   SUBR_NOP

CHANGE_REGS:
	clr	R1  
	tstb	CHP_ENABLED(R5)
	bne	CHANGE_REGS_NEXT

CHANGE_REGS_EXIT:
	movb	CHP_AMPL_REG(R5), R0
	mov	CUR_PARAMS_ADDR, R2
	add	R2, R0
	movb	R1, PARAM_AYREGS(R0)
	asrb	PARAM_AYREGS + AY_MIXER(R2)
	tstb	CHP_CURRENT_ONOFF(R5)
	beq	11$
	decb	CHP_CURRENT_ONOFF(R5)
	bne	11$
	movb	CHP_ONOFF_DELAY(R5), R0
	comb	CHP_ENABLED(R5)
	bne	10$
	movb	CHP_OFFON_DELAY(R5), R0
10$:	movb	R0, CHP_CURRENT_ONOFF(R5)
11$:	add	#CHP, R5
	return

CHANGE_REGS_NEXT:
	mov	CHP_ORNAMENTPOINTER(R5), R1 
	movb	(R1)+, R4   
	movb	(R1)+, R3   
	movb	CHP_POSITION_IN_ORNAMENT(R5), R0 
	add	R0, R1
	incb	R0
	cmpb	R0, R3
	blo	10$
	movb	R4, R0
10$:	movb	R0, CHP_POSITION_IN_ORNAMENT(R5)
	mov	CHP_NOTE(R5), R0 
	movb	(R1), R1 
	add	R1, R0
	bpl	11$
	clr	R0
11$:	cmp 	R0, #96.
	blo	12$
	mov	#95., R0
12$:	asl 	R0
	mov	R0, -(SP)   
	mov	CHP_SAMPLEPOINTER(R5), R1   
	movb	(R1)+, R4   
	movb	(R1)+, R3   
	movb	CHP_POSITION_IN_SAMPLE(R5), R0  
	add	R0, R1
	add	R0, R1
	add	R0, R1
	add	R0, R1
	incb	R0
	cmpb	R0, R3
	blo	13$
	movb	R4, R0
13$:	movb 	R0, CHP_POSITION_IN_SAMPLE(R5)
	movb	(R1)+, R3   
	movb	(R1)+, R4   
	clr	R2
	bisb	(R1)+, R2   
	swab	R2
	bisb	(R1), R2
	swab	R2
	add	CHP_TON_ACCUMULATOR(R5), R2
	bit	#^x40, R4   
	beq	14$
	mov	R2, CHP_TON_ACCUMULATOR(R5)
14$:	mov	(SP)+, R1   
	add	CUR_PARAMS_ADDR, R1
	add	PARAM_NOTE_TAB(R1), R2 
	mov	CHP_CURRENT_TON_SLIDING(R5), R1 
	add	R1, R2  
	bic	#^xF000, R2
	movb	CHP_TONE_REG(R5), R0
	add	CUR_PARAMS_ADDR, R0
	mov	R2, PARAM_AYREGS(R0)  

	tstb	CHP_TON_SLIDE_COUNT(R5)
	beq	17$
	decb	CHP_TON_SLIDE_COUNT(R5)
	bne	17$
	movb	CHP_TON_SLIDE_DELAY(R5), CHP_TON_SLIDE_COUNT(R5)
	mov	CHP_TON_SLIDE_STEP(R5), R2
	add	R2, R1  
	mov	R1, CHP_CURRENT_TON_SLIDING(R5)
	tstb	CHP_SIMPLEGLISS(R5) 
	bne	17$
	mov	CHP_TON_DELTA(R5), R0
	tst	R2  
  
	bpl	15$
	cmp	R1, R0
	ble	16$
	br	17$

15$:	cmp	R1, R0
	blt	17$
16$:	mov	CHP_SLIDE_TO_NOTE(R5), CHP_NOTE(R5)
	clrb	CHP_TON_SLIDE_COUNT(R5)
	clr	CHP_CURRENT_TON_SLIDING(R5)

17$: 	movb	CHP_CURRENT_AMPLITUDE_SLIDING(R5), R0   
	bit	#^x80, R3   
	beq	110$
	bit	#^x40, R3   
	beq	18$
	cmpb	R0, #15. 
	beq	110$
	incb	R0   
	br	19$
 
18$:	cmpb 	R0, #-15.   
	beq	110$
	decb	R0   
19$:	movb 	R0, CHP_CURRENT_AMPLITUDE_SLIDING(R5)
110$: 	mov	R4, R1  
	bic	#^xFFF0, R1 
	add	R1, R0  
	bpl	111$
	clr	R0
111$:	cmp	R0, #16.
	blo	112$
	mov	#15., R0 
112$:	bisb	CHP_VOLUME(R5), R0  
	add	CUR_PARAMS_ADDR, R0
	movb	PARAM_VOL_TAB(R0), R1 
	bit	#1, R3  
	bne	113$
	bisb	CHP_ENVELOPE_ENABLED(R5), R1 
113$:	mov	R3, R0
	asr	R0
	bic	#^xFFE0, R0 
	bit	#^x80, R4   
	beq	116$
	bit	#^x10, R0   
	beq	114$
	bis	#^xFFE0, R0 
114$:	add	CHP_CURRENT_ENVELOPE_SLIDING(R5), R0
	bit	#^x20, R4   
	beq	115$
	mov	R0, CHP_CURRENT_ENVELOPE_SLIDING(R5)
115$: 	mov	CUR_PARAMS_ADDR, R2
	add	R0, PARAM_ADDTOENVELOPE(R2)
	br	117$

116$: 	movb	CHP_CURRENT_NOISE_SLIDING(R5), R3   
	add	R3, R0
	mov	CUR_PARAMS_ADDR, R2
	mov	R0, PARAM_ADDTONOISE(R2)
	bit	#^x20, R4   
	beq	117$
	movb	R0, CHP_CURRENT_NOISE_SLIDING(R5)

117$:	asr	R4  
	bic	#177667, R4 
	bisb	R4, PARAM_AYREGS + AY_MIXER(R2)
	jmp	CHANGE_REGS_EXIT

FILL:	mov	R0, CHP_NOTE_SKIP_COUNTER(R4)
	mov	R2, CHP_ADDRESS_IN_PATTERN(R4)  
	mov	R2, CHP_ORNAMENTPOINTER(R4) 
	mov	R2, CHP_SAMPLEPOINTER(R4)   
	mov	R3, CHP_TONE_REG(R4)
	add	#CHP, R4
	return

TABLES:

TAB_C_OLD_0:
 	.BYTE	^x00 + 1, ^x04 + 1, ^x08 + 1, ^x0A + 1, ^x0C + 1, ^x0E + 1, ^x12 + 1, ^x14 + 1
 	.BYTE	^x18 + 1, ^x24 + 1, ^x3C + 1, 0
TAB_C_NEW_1:
TAB_C_OLD_1:
 	.BYTE	^x5C + 1, 0
TAB_C_OLD_2:
	.BYTE	^x30 + 1, ^x36 + 1, ^x4C + 1, ^x52 + 1, ^x5E + 1, ^x70 + 1, ^x82, ^x8C
 	.BYTE	^x9C, ^x9E, ^xA0, ^xA6, ^xA8, ^xAA, ^xAC, ^xAE, ^xAE, 0

TAB_C_NEW_3:
	.BYTE	^x56 + 1
TAB_C_OLD_3:
	.BYTE	^x1E + 1, ^x22 + 1, ^x24 + 1, ^x28 + 1, ^x2C + 1, ^x2E + 1, ^x32 + 1, ^xBE + 1, 0

TAB_C_NEW_0:
 	.BYTE	^x1C + 1, ^x20 + 1, ^x22 + 1, ^x26 + 1, ^x2A + 1, ^x2C + 1, ^x30 + 1, ^x54 + 1
	.BYTE	^xBC + 1, ^xBE + 1, 0

TAB_C_NEW_2:
	.BYTE	^x1A + 1, ^x20 + 1, ^x24 + 1, ^x28 + 1, ^x2A + 1, ^x3A + 1, ^x4C + 1, ^x5E + 1
	.BYTE	^xBA + 1, ^xBC + 1, ^xBE + 1, 0

EMPTY_SAM_ORN: 
	.BYTE	0, 1, 0, ^x90, 0, 0 
	.EVEN

TABLES_PACK:
 	.WORD	^x06EC
	.BYTE	^x0755-^x06EC
	.BYTE	^x07C5-^x0755
	.BYTE	^x083B-^x07C5
	.BYTE	^x08B8-^x083B
	.BYTE	^x093D-^x08B8
	.BYTE	^x09CA-^x093D
	.BYTE	^x0A5F-^x09CA
	.BYTE	^x0AFC-^x0A5F
	.BYTE	^x0BA4-^x0AFC
	.BYTE	^x0C55-^x0BA4
	.BYTE	^x0D10-^x0C55
	.BYTE	13.   
	.EVEN
	.WORD	^x066D
	.BYTE	^x06CF-^x066D
	.BYTE	^x0737-^x06CF
	.BYTE	^x07A4-^x0737
	.BYTE	^x0819-^x07A4
	.BYTE	^x0894-^x0819
	.BYTE	^x0917-^x0894
	.BYTE	^x09A1-^x0917
	.BYTE	^x0A33-^x09A1
	.BYTE	^x0ACF-^x0A33
	.BYTE	^x0B73-^x0ACF
	.BYTE	^x0C22-^x0B73
	.BYTE	^x0CDA-^x0C22
	.BYTE	12.   
	.EVEN
	.WORD	^x0704
	.BYTE	^x076E-^x0704
	.BYTE	^x07E0-^x076E
	.BYTE	^x0858-^x07E0
	.BYTE	^x08D6-^x0858
	.BYTE	^x095C-^x08D6
	.BYTE	^x09EC-^x095C
	.BYTE	^x0A82-^x09EC
	.BYTE	^x0B22-^x0A82
	.BYTE	^x0BCC-^x0B22
	.BYTE	^x0C80-^x0BCC
	.BYTE	^x0D3E-^x0C80
	.BYTE	12.   
	.EVEN
	.WORD	^x07E0
	.BYTE	^x0858-^x07E0
	.BYTE	^x08E0-^x0858
	.BYTE	^x0960-^x08E0
	.BYTE	^x09F0-^x0960
	.BYTE	^x0A88-^x09F0
	.BYTE	^x0B28-^x0A88
	.BYTE	^x0BD8-^x0B28
	.BYTE	^x0C80-^x0BD8
	.BYTE	^x0D60-^x0C80
	.BYTE	^x0E10-^x0D60
	.BYTE	^x0EF8-^x0E10
	.even

NT_DATA:
	.BYTE   PARAM_TAB_WORK_NEW_0 - PARAM_TAB_WORK, 0, TAB_C_NEW_0 - TABLES
	.BYTE   PARAM_TAB_WORK_OLD_0 - PARAM_TAB_WORK, 1, TAB_C_OLD_0 - TABLES
	.BYTE   PARAM_TAB_WORK_NEW_1 - PARAM_TAB_WORK, 1, TAB_C_NEW_1 - TABLES
	.BYTE   PARAM_TAB_WORK_OLD_1 - PARAM_TAB_WORK, 1, TAB_C_OLD_1 - TABLES
	.BYTE   PARAM_TAB_WORK_NEW_2 - PARAM_TAB_WORK, 0, TAB_C_NEW_2 - TABLES
	.BYTE   PARAM_TAB_WORK_OLD_2 - PARAM_TAB_WORK, 0, TAB_C_OLD_2 - TABLES
	.BYTE   PARAM_TAB_WORK_NEW_3 - PARAM_TAB_WORK, 0, TAB_C_NEW_3 - TABLES
	.BYTE   PARAM_TAB_WORK_OLD_3 - PARAM_TAB_WORK, 0, TAB_C_OLD_3 - TABLES
	.even



PT3FILE:
	@includebin test.pt3

PT3FILE_END:
	.even

PT3FILE_END_EVENED:

	;PARAM_DEVICES_AY1:
	;				.WORD 0 				;TURBOSOUND AY#1
	;				.WORD 100000			;MASK OF ONE OF THE GRYPHONSOUND AY
	;				.WORD AY_1_PORT_AZBK
	;	PARAMETERS_AY1:
	;				.BLKB PARAM_SIZE

	;PARAM_DEVICES_AY2:
	;				.WORD 1 				;TURBOSOUND AY#2
	;				.WORD 40000				;MASK OF ANOTHER GRYPHONSOUND AY
	;				.WORD AY_2_PORT_AZBK
	;	PARAMETERS_AY2:
	;				.BLKB PARAM_SIZE


	PARAM_DEVICES_AY1 = PT3FILE_END_EVENED
	PARAMETERS_AY1 = PARAM_DEVICES_AY1 + 6 ;SKIP TURBOSOUND SELECTOR (0), GRYPHONSOUND MASK (100000), PORT AZBK (AY_1_PORT_AZBK)

	PARAM_DEVICES_AY2 = PARAMETERS_AY1 + PARAM_SIZE
	PARAMETERS_AY2 = PARAM_DEVICES_AY2 + 6 ;SKIP TURBOSOUND SELECTOR (1), GRYPHONSOUND MASK (40000), PORT AZBK (AY_2_PORT_AZBK)


	.end	Start
